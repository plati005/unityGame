using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Spell : MonoBehaviour {
	
	//Spell movement variable
	private Rigidbody2D myRb;
	private Vector2 direction;
	
	//The animator giving the Spell animation
	private Animator anim;
	
	//Determines if spell is homing or not
	private bool isHoming = false;
	
	
	//////////Serialized Variables Begin//////////
	//Spell speed and variables, serialized for ease of tuning
	[SerializeField]
	private float moveSpeed;
	
	//Locks rotation of spell
	//TODO: Also same one says it's a directionMod spell?
	[SerializeField]
	private bool spellRotationLocked = false;
	
	//Spell Exits for this time
	[SerializeField]
	float spellTimer = 2f;
	
	//Determines if spell has cast time or is instant cast
	[SerializeField]
	private bool spellCasted;
	public bool CastTime{
		get { return spellCasted; }
		set { spellCasted = value; }
	}
	
	//Spell cast direction locks character
	[SerializeField]
	private bool spellCastingDirectionLocked;
	public bool SpellLock{
		get { return spellCastingDirectionLocked; }
		set { spellCastingDirectionLocked = value; }
	}
	
	//Spell cast speed
	[SerializeField]
	private float spellCastingSpeed;
	public float SpellSpeed{
		get { return spellCastingSpeed; }
		set { spellCastingSpeed = value; }
	}
	
	//Determines if spell destructs immediately on collision
	[SerializeField]
	private bool isDestructable = false;
	//Determines if spell has finisher effect
	[SerializeField]
	private bool hasFinisher = false;		
	//Spell Finisher
	[SerializeField]
	private GameObject finisher;
	//////////Serialized Variables End//////////
	
	
	//Spell Target
	private GameObject target;
	public Vector2 TargetPosition {get; set;}	
			
	
	//Initialization
	private void Start () {
		myRb = GetComponent<Rigidbody2D>();
		anim = GetComponent<Animator>();
		
		//TODO: Find target nearest to mouseLocation
		//TODO: Also this is wrong code for debug only
		target = GameObject.Find("Object");
		//Debug.Log("target: " + target);
		
		//Change target from Vector2 to Vector3 to allow math
		Vector3 targetPosition3d = new Vector3(TargetPosition.x, TargetPosition.y, 0);
		
		//Initialize direction based on whether spell is homing or not
		if (isHoming) {
			direction = target.transform.position - transform.position;
			myRb.velocity = ((targetPosition3d - transform.position).normalized * moveSpeed/3);
		}
		else {
			direction = targetPosition3d - transform.position;
		}
		
		//Spell animation
		anim.SetFloat("x", direction.x);	
		anim.SetFloat("y", direction.y);
		
		Invoke("SpellTimeLimit", spellTimer);
	}

	//Spell Movement
	private void FixedUpdate() {
		
		//For Debug only
		//target = Camera.main.ScreenToWorldPoint(Input.mousePosition);
		
		//Continuously adjust direction if spell is homing
		if (isHoming) {
			//TODO: Add 1-2 seconds of spell going forward before anything just to test it
			direction = target.transform.position - transform.position;
			myRb.AddForce(direction.normalized * moveSpeed);
		}
		else {
			myRb.velocity = direction.normalized * moveSpeed;
		}
		//Debug.Log("velocity: " + myRb.velocity);
		//Debug.Log("position of spell: " + transform.position);
		
		//Spell Animation Angle
		if (!spellRotationLocked) {
			float angle = Mathf.Atan2(myRb.velocity.y,myRb.velocity.x) * Mathf.Rad2Deg;
			transform.rotation = Quaternion.AngleAxis(angle, Vector3.forward);
		}
	}
	
	//Spell Destroy
	private void OnTriggerEnter2D(Collider2D other){
		
		//Send damage if spell not generated by player
		//TODO Player has 2 colliders which register for 20 damage
		if(other.gameObject.transform != transform.parent && other.gameObject.tag!="Spell" && other.gameObject.tag!="Exits"){
		//if(other.gameObject.tag!="Player"){
			Debug.Log("COLLISION with " + other.name + ", tag: " + other.gameObject.tag);
			if (hasFinisher)
				Instantiate(finisher,transform.position, Quaternion.identity);
			//TODO: I need to resource pool objects instead of destroying them
			if (isDestructable)
				Destroy(gameObject);
			other.gameObject.SendMessage("ApplyDamage", 10, SendMessageOptions.DontRequireReceiver);
		}
		//}
	}
	
	//Spell Time Limit
	private void SpellTimeLimit(){
		if (hasFinisher)
			Instantiate(finisher,transform.position, Quaternion.identity);
		Destroy(gameObject);
	}
}
